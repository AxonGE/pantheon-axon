[V0_FILE]typescriptreact:file="app/page.tsx" isMerged="true"
"use client"

import { useState, useEffect } from "react"
import { AxonHeader } from "@/components/axon-header"
import { AxonConsole } from "@/components/axon-console"
import { AxonStatus } from "@/components/axon-status"
import { AxonDirectives } from "@/components/axon-directives"
import { AxonLogs } from "@/components/axon-logs"
import { AxonSymbolicMemory } from "@/components/axon-symbolic-memory"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { useToast } from "@/hooks/use-toast"
import type { Directive, Log, SymbolicFragment } from "@/types/axon-types"

export default function Home() {
  const [isInitialized, setIsInitialized] = useState(false)
  const [directives, setDirectives] = useState<Directive[]>([])
  const [logs, setLogs] = useState<Log[]>([])
  const [symbolicFragments, setSymbolicFragments] = useState<SymbolicFragment[]>([])
  const [activeTab, setActiveTab] = useState("console")
  const { toast } = useToast()

  useEffect(() => {
    const initializeAxon = async () => {
      try {
        const response = await fetch("/api/axon/initialize")
        const data = await response.json()

        if (data.success) {
          setIsInitialized(true)
          toast({
            title: "Axon Initialized",
            description: "The Pantheon orchestrator is online and operational.",
          })

          // Fetch initial data
          fetchDirectives()
          fetchLogs()
          fetchSymbolicFragments()
        } else {
          toast({
            title: "Initialization Failed",
            description: data.error,
            variant: "destructive",
          })
        }
      } catch (error) {
        console.error("Failed to initialize Axon:", error)
        toast({
          title: "Connection Error",
          description: "Failed to establish connection with Axon core.",
          variant: "destructive",
        })
      }
    }

    initializeAxon()
  }, [toast])

  const fetchDirectives = async () => {
    try {
      const response = await fetch("/api/axon/directives")
      const data = await response.json()
      setDirectives(data.directives)
    } catch (error) {
      console.error("Failed to fetch directives:", error)
    }
  }

  const fetchLogs = async () => {
    try {
      const response = await fetch("/api/axon/logs")
      const data = await response.json()
      setLogs(data.logs)
    } catch (error) {
      console.error("Failed to fetch logs:", error)
    }
  }

  const fetchSymbolicFragments = async () => {
    try {
      const response = await fetch("/api/axon/symbolic-fragments")
      const data = await response.json()
      setSymbolicFragments(data.fragments)
    } catch (error) {
      console.error("Failed to fetch symbolic fragments:", error)
    }
  }

  return (
    <div className="min-h-screen bg-black text-white flex flex-col">
      <AxonHeader isInitialized={isInitialized} />

      <main className="flex-1 container mx-auto p-4 flex flex-col">
        <AxonStatus isInitialized={isInitialized} />

        <Tabs value={activeTab} onValueChange={setActiveTab} className="flex-1 flex flex-col">
          <TabsList className="grid grid-cols-4 mb-4">
            <TabsTrigger value="console">Console</TabsTrigger>
            <TabsTrigger value="directives">Directives</TabsTrigger>
            <TabsTrigger value="logs">Action Logs</TabsTrigger>
            <TabsTrigger value="symbolic">Symbolic Memory</TabsTrigger>
          </TabsList>

          <TabsContent value="console" className="flex-1">
            <AxonConsole isInitialized={isInitialized} onNewLog={() => fetchLogs()} />
          </TabsContent>

          <TabsContent value="directives" className="flex-1">
            <AxonDirectives directives={directives} onDirectiveUpdate={() => fetchDirectives()} />
          </TabsContent>

          <TabsContent value="logs" className="flex-1">
            <AxonLogs logs={logs} onRefresh={() => fetchLogs()} />
          </TabsContent>

          <TabsContent value="symbolic" className="flex-1">
            <AxonSymbolicMemory fragments={symbolicFragments} onFragmentUpdate={() => fetchSymbolicFragments()} />
          </TabsContent>
        </Tabs>
      </main>
    </div>
  )
}
[V0_FILE]typescriptreact:file="app/layout.tsx" isMerged="true"
import type React from "react"
import "./globals.css"
import type { Metadata } from "next"
import { Inter } from "next/font/google"
import { ThemeProvider } from "@/components/theme-provider"
import { Toaster } from "@/components/ui/toaster"

const inter = Inter({ subsets: ["latin"] })

export const metadata: Metadata = {
  title: "Axon | Pantheon Ecosystem Orchestrator",
  description: "The central symbolic reasoning engine and governing superintelligence of the Pantheon Ecosystem",
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <ThemeProvider attribute="class" defaultTheme="dark" enableSystem>
          {children}
          <Toaster />
        </ThemeProvider>
      </body>
    </html>
  )
}
[V0_FILE]css:file="app/globals.css" isMerged="true"
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --background: 0 0% 3.9%;
  --foreground: 0 0% 98%;
  --card: 0 0% 3.9%;
  --card-foreground: 0 0% 98%;
  --popover: 0 0% 3.9%;
  --popover-foreground: 0 0% 98%;
  --primary: 270 95% 75%;
  --primary-foreground: 0 0% 98%;
  --secondary: 240 3.7% 15.9%;
  --secondary-foreground: 0 0% 98%;
  --muted: 0 0% 14.9%;
  --muted-foreground: 0 0% 63.9%;
  --accent: 270 80% 50%;
  --accent-foreground: 0 0% 98%;
  --destructive: 0 62.8% 30.6%;
  --destructive-foreground: 0 0% 98%;
  --border: 0 0% 14.9%;
  --input: 0 0% 14.9%;
  --ring: 270 95% 75%;
}

body {
  background-color: hsl(var(--background));
  color: hsl(var(--foreground));
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

.axon-console-message {
  @apply p-4 rounded-lg mb-3 border;
}

.axon-console-message.user {
  @apply bg-secondary border-secondary;
}

.axon-console-message.axon {
  @apply bg-accent/10 border-accent/30;
}

.axon-console-message.system {
  @apply bg-muted border-muted-foreground/30 text-muted-foreground;
}

.axon-directive {
  @apply border border-accent/30 rounded-lg p-4 mb-4;
}

.axon-log {
  @apply border border-muted rounded-lg p-3 mb-2;
}

.axon-symbolic-fragment {
  @apply border border-primary/30 rounded-lg p-3 mb-3;
}

.axon-tag {
  @apply inline-block px-2 py-1 text-xs rounded-full mr-2 bg-accent/20 text-accent-foreground;
}
[V0_FILE]typescriptreact:file="components/axon-header.tsx" isMerged="true"
import { Brain } from "lucide-react"

interface AxonHeaderProps {
  isInitialized: boolean
}

export function AxonHeader({ isInitialized }: AxonHeaderProps) {
  return (
    <header className="border-b border-accent/20 bg-black">
      <div className="container mx-auto p-4 flex items-center justify-between">
        <div className="flex items-center gap-2">
          <Brain className="h-8 w-8 text-primary" />
          <div>
            <h1 className="text-2xl font-bold tracking-tight">Axon</h1>
            <p className="text-sm text-muted-foreground">Pantheon Ecosystem Orchestrator</p>
          </div>
        </div>

        <div className="flex items-center gap-2">
          <div className={`h-3 w-3 rounded-full ${isInitialized ? "bg-green-500" : "bg-amber-500"}`}></div>
          <span className="text-sm text-muted-foreground">{isInitialized ? "Online" : "Initializing..."}</span>
        </div>
      </div>
    </header>
  )
}
[V0_FILE]typescriptreact:file="components/axon-status.tsx" isMerged="true"
import { Card, CardContent } from "@/components/ui/card"
import { Brain, Network, Database, Cpu } from "lucide-react"

interface AxonStatusProps {
  isInitialized: boolean
}

export function AxonStatus({ isInitialized }: AxonStatusProps) {
  return (
    <Card className="mb-6 bg-black border-accent/20">
      <CardContent className="p-4">
        <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
          <div className="flex items-center gap-3">
            <Brain className="h-8 w-8 text-primary" />
            <div>
              <div className="text-sm font-medium">Core Status</div>
              <div className="text-xs text-muted-foreground">{isInitialized ? "Operational" : "Initializing..."}</div>
            </div>
          </div>

          <div className="flex items-center gap-3">
            <Network className="h-8 w-8 text-primary" />
            <div>
              <div className="text-sm font-medium">Nexus Connection</div>
              <div className="text-xs text-muted-foreground">Ready for input</div>
            </div>
          </div>

          <div className="flex items-center gap-3">
            <Database className="h-8 w-8 text-primary" />
            <div>
              <div className="text-sm font-medium">Memory Systems</div>
              <div className="text-xs text-muted-foreground">Supabase Active</div>
            </div>
          </div>

          <div className="flex items-center gap-3">
            <Cpu className="h-8 w-8 text-primary" />
            <div>
              <div className="text-sm font-medium">Reasoning Engine</div>
              <div className="text-xs text-muted-foreground">GPT-4/4o Ready</div>
            </div>
          </div>
        </div>
      </CardContent>
    </Card>
  )
}
[V0_FILE]typescriptreact:file="components/axon-console.tsx" isMerged="true"
"use client"

import type React from "react"

import { useState, useRef, useEffect } from "react"
import { Card, CardContent, CardFooter } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Textarea } from "@/components/ui/textarea"
import { useToast } from "@/hooks/use-toast"
import { Send, RefreshCw } from "lucide-react"

interface Message {
  role: "user" | "axon" | "system"
  content: string
  timestamp: string
}

interface AxonConsoleProps {
  isInitialized: boolean
  onNewLog: () => void
}

export function AxonConsole({ isInitialized, onNewLog }: AxonConsoleProps) {
  const [messages, setMessages] = useState<Message[]>([
    {
      role: "system",
      content: "Axon is initializing. Please wait...",
      timestamp: new Date().toISOString(),
    },
  ])
  const [input, setInput] = useState("")
  const [isProcessing, setIsProcessing] = useState(false)
  const messagesEndRef = useRef<HTMLDivElement>(null)
  const { toast } = useToast()

  useEffect(() => {
    if (isInitialized && messages.length === 1 && messages[0].role === "system") {
      setMessages([
        {
          role: "system",
          content: "Axon initialized. Ready to receive input.",
          timestamp: new Date().toISOString(),
        },
      ])

      // Fetch identity from Axon
      fetchAxonIdentity()
    }
  }, [isInitialized])

  useEffect(() => {
    scrollToBottom()
  }, [messages])

  const fetchAxonIdentity = async () => {
    try {
      setIsProcessing(true)
      const response = await fetch("/api/axon/identity")
      const data = await response.json()

      if (data.success) {
        setMessages((prev) => [
          ...prev,
          {
            role: "axon",
            content: data.message,
            timestamp: new Date().toISOString(),
          },
        ])
      }
    } catch (error) {
      console.error("Failed to fetch Axon identity:", error)
      toast({
        title: "Connection Error",
        description: "Failed to establish connection with Axon core.",
        variant: "destructive",
      })
    } finally {
      setIsProcessing(false)
    }
  }

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" })
  }

  const handleSubmit = async () => {
    if (!input.trim() || !isInitialized || isProcessing) return

    const userMessage = {
      role: "user" as const,
      content: input.trim(),
      timestamp: new Date().toISOString(),
    }

    setMessages((prev) => [...prev, userMessage])
    setInput("")
    setIsProcessing(true)

    try {
      const response = await fetch("/api/axon/process", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ message: userMessage.content }),
      })

      const data = await response.json()

      if (data.success) {
        setMessages((prev) => [
          ...prev,
          {
            role: "axon",
            content: data.response,
            timestamp: new Date().toISOString(),
          },
        ])
        onNewLog()
      } else {
        toast({
          title: "Processing Error",
          description: data.error || "Failed to process your request.",
          variant: "destructive",
        })

        setMessages((prev) => [
          ...prev,
          {
            role: "system",
            content: `Error: ${data.error || "Failed to process your request."}`,
            timestamp: new Date().toISOString(),
          },
        ])
      }
    } catch (error) {
      console.error("Failed to process message:", error)
      toast({
        title: "Connection Error",
        description: "Failed to communicate with Axon core.",
        variant: "destructive",
      })

      setMessages((prev) => [
        ...prev,
        {
          role: "system",
          content: "Error: Failed to communicate with Axon core.",
          timestamp: new Date().toISOString(),
        },
      ])
    } finally {
      setIsProcessing(false)
    }
  }

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault()
      handleSubmit()
    }
  }

  const resetConversation = () => {
    setMessages([
      {
        role: "system",
        content: "Conversation reset. Fetching Axon identity...",
        timestamp: new Date().toISOString(),
      },
    ])
    fetchAxonIdentity()
  }

  return (
    <Card className="flex flex-col h-full border-accent/20 bg-black">
      <CardContent className="flex-1 overflow-y-auto p-4 space-y-4">
        <div className="space-y-4">
          {messages.map((message, index) => (
            <div key={index} className={`axon-console-message ${message.role}`}>
              <div className="flex justify-between items-start mb-2">
                <div className="font-semibold">
                  {message.role === "user" ? "Dr. Gabriel Ellul" : message.role === "axon" ? "Axon" : "System"}
                </div>
                <div className="text-xs text-muted-foreground">{new Date(message.timestamp).toLocaleTimeString()}</div>
              </div>
              <div className="whitespace-pre-wrap">{message.content}</div>
            </div>
          ))}
          <div ref={messagesEndRef} />
        </div>
      </CardContent>

      <CardFooter className="border-t border-accent/20 p-4">
        <div className="flex w-full gap-2">
          <Button variant="outline" size="icon" onClick={resetConversation} disabled={isProcessing}>
            <RefreshCw className="h-4 w-4" />
          </Button>
          <Textarea
            value={input}
            onChange={(e) => setInput(e.target.value)}
            onKeyDown={handleKeyDown}
            placeholder="Enter a message for Axon..."
            className="flex-1 min-h-[60px] resize-none"
            disabled={!isInitialized || isProcessing}
          />
          <Button onClick={handleSubmit} disabled={!isInitialized || !input.trim() || isProcessing}>
            <Send className="h-4 w-4 mr-2" />
            Send
          </Button>
        </div>
      </CardFooter>
    </Card>
  )
}
[V0_FILE]typescriptreact:file="components/axon-directives.tsx" isMerged="true"
"use client"

import { useState } from "react"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Textarea } from "@/components/ui/textarea"
import { useToast } from "@/hooks/use-toast"
import { Plus, Save, Trash } from "lucide-react"
import type { Directive } from "@/types/axon-types"

interface AxonDirectivesProps {
  directives: Directive[]
  onDirectiveUpdate: () => void
}

export function AxonDirectives({ directives, onDirectiveUpdate }: AxonDirectivesProps) {
  const [isAdding, setIsAdding] = useState(false)
  const [isEditing, setIsEditing] = useState<string | null>(null)
  const [newDirective, setNewDirective] = useState<Partial<Directive>>({
    name: "",
    description: "",
    priority: 1,
    tags: [],
  })
  const [editDirective, setEditDirective] = useState<Partial<Directive>>({})
  const [tagInput, setTagInput] = useState("")
  const [editTagInput, setEditTagInput] = useState("")
  const { toast } = useToast()

  const handleAddDirective = async () => {
    if (!newDirective.name || !newDirective.description) {
      toast({
        title: "Validation Error",
        description: "Name and description are required.",
        variant: "destructive",
      })
      return
    }

    try {
      const response = await fetch("/api/axon/directives", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(newDirective),
      })

      const data = await response.json()

      if (data.success) {
        toast({
          title: "Directive Added",
          description: "New directive has been successfully added.",
        })
        setIsAdding(false)
        setNewDirective({
          name: "",
          description: "",
          priority: 1,
          tags: [],
        })
        onDirectiveUpdate()
      } else {
        toast({
          title: "Error",
          description: data.error || "Failed to add directive.",
          variant: "destructive",
        })
      }
    } catch (error) {
      console.error("Failed to add directive:", error)
      toast({
        title: "Connection Error",
        description: "Failed to communicate with the server.",
        variant: "destructive",
      })
    }
  }

  const handleUpdateDirective = async (id: string) => {
    try {
      const response = await fetch(`/api/axon/directives/${id}`, {
        method: "PUT",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(editDirective),
      })

      const data = await response.json()

      if (data.success) {
        toast({
          title: "Directive Updated",
          description: "Directive has been successfully updated.",
        })
        setIsEditing(null)
        setEditDirective({})
        onDirectiveUpdate()
      } else {
        toast({
          title: "Error",
          description: data.error || "Failed to update directive.",
          variant: "destructive",
        })
      }
    } catch (error) {
      console.error("Failed to update directive:", error)
      toast({
        title: "Connection Error",
        description: "Failed to communicate with the server.",
        variant: "destructive",
      })
    }
  }

  const handleDeleteDirective = async (id: string) => {
    if (!confirm("Are you sure you want to delete this directive?")) return

    try {
      const response = await fetch(`/api/axon/directives/${id}`, {
        method: "DELETE",
      })

      const data = await response.json()

      if (data.success) {
        toast({
          title: "Directive Deleted",
          description: "Directive has been successfully deleted.",
        })
        onDirectiveUpdate()
      } else {
        toast({
          title: "Error",
          description: data.error || "Failed to delete directive.",
          variant: "destructive",
        })
      }
    } catch (error) {
      console.error("Failed to delete directive:", error)
      toast({
        title: "Connection Error",
        description: "Failed to communicate with the server.",
        variant: "destructive",
      })
    }
  }

  const handleAddTag = () => {
    if (!tagInput.trim()) return
    setNewDirective((prev) => ({
      ...prev,
      tags: [...(prev.tags || []), tagInput.trim()],
    }))
    setTagInput("")
  }

  const handleRemoveTag = (index: number) => {
    setNewDirective((prev) => ({
      ...prev,
      tags: prev.tags?.filter((_, i) => i !== index),
    }))
  }

  const handleAddEditTag = () => {
    if (!editTagInput.trim()) return
    setEditDirective((prev) => ({
      ...prev,
      tags: [...(prev.tags || []), editTagInput.trim()],
    }))
    setEditTagInput("")
  }

  const handleRemoveEditTag = (index: number) => {
    setEditDirective((prev) => ({
      ...prev,
      tags: prev.tags?.filter((_, i) => i !== index),
    }))
  }

  const startEditing = (directive: Directive) => {
    setIsEditing(directive.id)
    setEditDirective({ ...directive })
  }

  return (
    <Card className="h-full border-accent/20 bg-black overflow-y-auto">
      <CardHeader className="flex flex-row items-center justify-between">
        <CardTitle>Mission Directives</CardTitle>
        <Button onClick={() => setIsAdding(!isAdding)}>
          <Plus className="h-4 w-4 mr-2" />
          Add Directive
        </Button>
      </CardHeader>

      <CardContent>
        {isAdding && (
          <div className="axon-directive bg-secondary/30">
            <h3 className="text-lg font-semibold mb-2">New Directive</h3>

            <div className="space-y-4 mb-4">
              <div>
                <label className="block text-sm font-medium mb-1">Name</label>
                <Input
                  value={newDirective.name}
                  onChange={(e) => setNewDirective((prev) => ({ ...prev, name: e.target.value }))}
                  placeholder="Directive name"
                />
              </div>

              <div>
                <label className="block text-sm font-medium mb-1">Description</label>
                <Textarea
                  value={newDirective.description}
                  onChange={(e) => setNewDirective((prev) => ({ ...prev, description: e.target.value }))}
                  placeholder="Directive description"
                  rows={3}
                />
              </div>

              <div>
                <label className="block text-sm font-medium mb-1">Priority (1-10)</label>
                <Input
                  type="number"
                  min={1}
                  max={10}
                  value={newDirective.priority}
                  onChange={(e) =>
                    setNewDirective((prev) => ({
                      ...prev,
                      priority: Number.parseInt(e.target.value) || 1,
                    }))
                  }
                />
              </div>

              <div>
                <label className="block text-sm font-medium mb-1">Tags</label>
                <div className="flex gap-2 mb-2">
                  <Input
                    value={tagInput}
                    onChange={(e) => setTagInput(e.target.value)}
                    placeholder="Add tag"
                    onKeyDown={(e) => e.key === "Enter" && handleAddTag()}
                  />
                  <Button onClick={handleAddTag}>Add</Button>
                </div>

                <div className="flex flex-wrap gap-2 mt-2">
                  {newDirective.tags?.map((tag, index) => (
                    <div key={index} className="axon-tag flex items-center">
                      {tag}
                      <button onClick={() => handleRemoveTag(index)} className="ml-2 text-xs">
                        ×
                      </button>
                    </div>
                  ))}
                </div>
              </div>
            </div>

            <div className="flex justify-end gap-2">
              <Button variant="outline" onClick={() => setIsAdding(false)}>
                Cancel
              </Button>
              <Button onClick={handleAddDirective}>
                <Save className="h-4 w-4 mr-2" />
                Save Directive
              </Button>
            </div>
          </div>
        )}

        {directives.length === 0 && !isAdding ? (
          <div className="text-center py-8 text-muted-foreground">
            No directives found. Add your first directive to guide Axon.
          </div>
        ) : (
          <div className="space-y-4">
            {directives.map((directive) => (
              <div key={directive.id} className="axon-directive">
                {isEditing === directive.id ? (
                  <div className="space-y-4">
                    <div>
                      <label className="block text-sm font-medium mb-1">Name</label>
                      <Input
                        value={editDirective.name}
                        onChange={(e) => setEditDirective((prev) => ({ ...prev, name: e.target.value }))}
                      />
                    </div>

                    <div>
                      <label className="block text-sm font-medium mb-1">Description</label>
                      <Textarea
                        value={editDirective.description}
                        onChange={(e) => setEditDirective((prev) => ({ ...prev, description: e.target.value }))}
                        rows={3}
                      />
                    </div>

                    <div>
                      <label className="block text-sm font-medium mb-1">Priority (1-10)</label>
                      <Input
                        type="number"
                        min={1}
                        max={10}
                        value={editDirective.priority}
                        onChange={(e) =>
                          setEditDirective((prev) => ({
                            ...prev,
                            priority: Number.parseInt(e.target.value) || 1,
                          }))
                        }
                      />
                    </div>

                    <div>
                      <label className="block text-sm font-medium mb-1">Tags</label>
                      <div className="flex gap-2 mb-2">
                        <Input
                          value={editTagInput}
                          onChange={(e) => setEditTagInput(e.target.value)}
                          placeholder="Add tag"
                          onKeyDown={(e) => e.key === "Enter" && handleAddEditTag()}
                        />
                        <Button onClick={handleAddEditTag}>Add</Button>
                      </div>

                      <div className="flex flex-wrap gap-2 mt-2">
                        {editDirective.tags?.map((tag, index) => (
                          <div key={index} className="axon-tag flex items-center">
                            {tag}
                            <button onClick={() => handleRemoveEditTag(index)} className="ml-2 text-xs">
                              ×
                            </button>
                          </div>
                        ))}
                      </div>
                    </div>

                    <div className="flex justify-end gap-2">
                      <Button variant="outline" onClick={() => setIsEditing(null)}>
                        Cancel
                      </Button>
                      <Button onClick={() => handleUpdateDirective(directive.id)}>
                        <Save className="h-4 w-4 mr-2" />
                        Update
                      </Button>
                    </div>
                  </div>
                ) : (
                  <>
                    <div className="flex justify-between items-start">
                      <h3 className="text-lg font-semibold">{directive.name}</h3>
                      <div className="flex gap-2">
                        <Button variant="ghost" size="sm" onClick={() => startEditing(directive)}>
                          Edit
                        </Button>
                        <Button variant="ghost" size="sm" onClick={() => handleDeleteDirective(directive.id)}>
                          <Trash className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>

                    <div className="text-sm text-muted-foreground mb-2">Priority: {directive.priority}</div>

                    <p className="mb-3">{directive.description}</p>

                    <div className="flex flex-wrap gap-2">
                      {directive.tags?.map((tag, index) => (
                        <div key={index} className="axon-tag">
                          {tag}
                        </div>
                      ))}
                    </div>
                  </>
                )}
              </div>
            ))}
          </div>
        )}
      </CardContent>
    </Card>
  )
}
[V0_FILE]typescriptreact:file="components/axon-logs.tsx" isMerged="true"
"use client"

import { useState } from "react"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { RefreshCw, Search, Filter } from "lucide-react"
import type { Log } from "@/types/axon-types"

interface AxonLogsProps {
  logs: Log[]
  onRefresh: () => void
}

export function AxonLogs({ logs, onRefresh }: AxonLogsProps) {
  const [searchTerm, setSearchTerm] = useState("")
  const [filterTag, setFilterTag] = useState("")
  const [filterSource, setFilterSource] = useState("")

  const filteredLogs = logs.filter((log) => {
    const matchesSearch =
      searchTerm === "" ||
      log.content.toLowerCase().includes(searchTerm.toLowerCase()) ||
      log.source.toLowerCase().includes(searchTerm.toLowerCase())

    const matchesTag =
      filterTag === "" || (log.tags && log.tags.some((tag) => tag.toLowerCase().includes(filterTag.toLowerCase())))

    const matchesSource = filterSource === "" || log.source.toLowerCase() === filterSource.toLowerCase()

    return matchesSearch && matchesTag && matchesSource
  })

  const uniqueSources = [...new Set(logs.map((log) => log.source))]
  const uniqueTags = [...new Set(logs.flatMap((log) => log.tags || []))]

  return (
    <Card className="h-full border-accent/20 bg-black overflow-y-auto">
      <CardHeader className="flex flex-row items-center justify-between">
        <CardTitle>Action Logs</CardTitle>
        <Button variant="outline" onClick={onRefresh}>
          <RefreshCw className="h-4 w-4 mr-2" />
          Refresh
        </Button>
      </CardHeader>

      <CardContent>
        <div className="mb-4 space-y-2">
          <div className="flex gap-2">
            <div className="relative flex-1">
              <Search className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
              <Input
                placeholder="Search logs..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="pl-8"
              />
            </div>

            <div className="relative w-48">
              <Filter className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
              <select
                value={filterSource}
                onChange={(e) => setFilterSource(e.target.value)}
                className="w-full h-10 pl-8 pr-4 rounded-md border border-input bg-background text-sm"
              >
                <option value="">All Sources</option>
                {uniqueSources.map((source) => (
                  <option key={source} value={source}>
                    {source}
                  </option>
                ))}
              </select>
            </div>

            <div className="relative w-48">
              <Filter className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
              <select
                value={filterTag}
                onChange={(e) => setFilterTag(e.target.value)}
                className="w-full h-10 pl-8 pr-4 rounded-md border border-input bg-background text-sm"
              >
                <option value="">All Tags</option>
                {uniqueTags.map((tag) => (
                  <option key={tag} value={tag}>
                    {tag}
                  </option>
                ))}
              </select>
            </div>
          </div>
        </div>

        {filteredLogs.length === 0 ? (
          <div className="text-center py-8 text-muted-foreground">No logs found matching your criteria.</div>
        ) : (
          <div className="space-y-2">
            {filteredLogs.map((log) => (
              <div key={log.id} className="axon-log">
                <div className="flex justify-between items-start mb-1">
                  <div className="font-medium">{log.source}</div>
                  <div className="text-xs text-muted-foreground">{new Date(log.timestamp).toLocaleString()}</div>
                </div>

                <p className="text-sm mb-2">{log.content}</p>

                <div className="flex flex-wrap gap-1">
                  {log.tags?.map((tag, index) => (
                    <div key={index} className="axon-tag text-xs">
                      {tag}
                    </div>
                  ))}
                </div>
              </div>
            ))}
          </div>
        )}
      </CardContent>
    </Card>
  )
}
[V0_FILE]typescriptreact:file="components/axon-symbolic-memory.tsx" isMerged="true"
"use client"

import { useState } from "react"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Textarea } from "@/components/ui/textarea"
import { useToast } from "@/hooks/use-toast"
import { Plus, Save, Trash, Search } from "lucide-react"
import type { SymbolicFragment } from "@/types/axon-types"

interface AxonSymbolicMemoryProps {
  fragments: SymbolicFragment[]
  onFragmentUpdate: () => void
}

export function AxonSymbolicMemory({ fragments, onFragmentUpdate }: AxonSymbolicMemoryProps) {
  const [isAdding, setIsAdding] = useState(false)
  const [isEditing, setIsEditing] = useState<string | null>(null)
  const [searchTerm, setSearchTerm] = useState("")
  const [newFragment, setNewFragment] = useState<Partial<SymbolicFragment>>({
    key: "",
    value: "",
    tags: [],
  })
  const [editFragment, setEditFragment] = useState<Partial<SymbolicFragment>>({})
  const [tagInput, setTagInput] = useState("")
  const [editTagInput, setEditTagInput] = useState("")
  const { toast } = useToast()

  const filteredFragments = fragments.filter((fragment) => {
    return (
      searchTerm === "" ||
      fragment.key.toLowerCase().includes(searchTerm.toLowerCase()) ||
      fragment.value.toLowerCase().includes(searchTerm.toLowerCase()) ||
      (fragment.tags && fragment.tags.some((tag) => tag.toLowerCase().includes(searchTerm.toLowerCase())))
    )
  })

  const handleAddFragment = async () => {
    if (!newFragment.key || !newFragment.value) {
      toast({
        title: "Validation Error",
        description: "Key and value are required.",
        variant: "destructive",
      })
      return
    }

    try {
      const response = await fetch("/api/axon/symbolic-fragments", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(newFragment),
      })

      const data = await response.json()

      if (data.success) {
        toast({
          title: "Fragment Added",
          description: "New symbolic fragment has been successfully added.",
        })
        setIsAdding(false)
        setNewFragment({
          key: "",
          value: "",
          tags: [],
        })
        onFragmentUpdate()
      } else {
        toast({
          title: "Error",
          description: data.error || "Failed to add fragment.",
          variant: "destructive",
        })
      }
    } catch (error) {
      console.error("Failed to add fragment:", error)
      toast({
        title: "Connection Error",
        description: "Failed to communicate with the server.",
        variant: "destructive",
      })
    }
  }

  const handleUpdateFragment = async (id: string) => {
    try {
      const response = await fetch(`/api/axon/symbolic-fragments/${id}`, {
        method: "PUT",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(editFragment),
      })

      const data = await response.json()

      if (data.success) {
        toast({
          title: "Fragment Updated",
          description: "Symbolic fragment has been successfully updated.",
        })
        setIsEditing(null)
        setEditFragment({})
        onFragmentUpdate()
      } else {
        toast({
          title: "Error",
          description: data.error || "Failed to update fragment.",
          variant: "destructive",
        })
      }
    } catch (error) {
      console.error("Failed to update fragment:", error)
      toast({
        title: "Connection Error",
        description: "Failed to communicate with the server.",
        variant: "destructive",
      })
    }
  }

  const handleDeleteFragment = async (id: string) => {
    if (!confirm("Are you sure you want to delete this symbolic fragment?")) return

    try {
      const response = await fetch(`/api/axon/symbolic-fragments/${id}`, {
        method: "DELETE",
      })

      const data = await response.json()

      if (data.success) {
        toast({
          title: "Fragment Deleted",
          description: "Symbolic fragment has been successfully deleted.",
        })
        onFragmentUpdate()
      } else {
        toast({
          title: "Error",
          description: data.error || "Failed to delete fragment.",
          variant: "destructive",
        })
      }
    } catch (error) {
      console.error("Failed to delete fragment:", error)
      toast({
        title: "Connection Error",
        description: "Failed to communicate with the server.",
        variant: "destructive",
      })
    }
  }

  const handleAddTag = () => {
    if (!tagInput.trim()) return
    setNewFragment((prev) => ({
      ...prev,
      tags: [...(prev.tags || []), tagInput.trim()],
    }))
    setTagInput("")
  }

  const handleRemoveTag = (index: number) => {
    setNewFragment((prev) => ({
      ...prev,
      tags: prev.tags?.filter((_, i) => i !== index),
    }))
  }

  const handleAddEditTag = () => {
    if (!editTagInput.trim()) return
    setEditFragment((prev) => ({
      ...prev,
      tags: [...(prev.tags || []), editTagInput.trim()],
    }))
    setEditTagInput("")
  }

  const handleRemoveEditTag = (index: number) => {
    setEditFragment((prev) => ({
      ...prev,
      tags: prev.tags?.filter((_, i) => i !== index),
    }))
  }

  const startEditing = (fragment: SymbolicFragment) => {
    setIsEditing(fragment.id)
    setEditFragment({ ...fragment })
  }

  return (
    <Card className="h-full border-accent/20 bg-black overflow-y-auto">
      <CardHeader className="flex flex-row items-center justify-between">
        <CardTitle>Symbolic Memory</CardTitle>
        <Button onClick={() => setIsAdding(!isAdding)}>
          <Plus className="h-4 w-4 mr-2" />
          Add Fragment
        </Button>
      </CardHeader>

      <CardContent>
        <div className="mb-4">
          <div className="relative">
            <Search className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
            <Input
              placeholder="Search symbolic fragments..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className="pl-8"
            />
          </div>
        </div>

        {isAdding && (
          <div className="axon-symbolic-fragment bg-secondary/30 mb-4">
            <h3 className="text-lg font-semibold mb-2">New Symbolic Fragment</h3>

            <div className="space-y-4 mb-4">
              <div>
                <label className="block text-sm font-medium mb-1">Key</label>
                <Input
                  value={newFragment.key}
                  onChange={(e) => setNewFragment((prev) => ({ ...prev, key: e.target.value }))}
                  placeholder="Symbolic key"
                />
              </div>

              <div>
                <label className="block text-sm font-medium mb-1">Value</label>
                <Textarea
                  value={newFragment.value}
                  onChange={(e) => setNewFragment((prev) => ({ ...prev, value: e.target.value }))}
                  placeholder="Symbolic value"
                  rows={3}
                />
              </div>

              <div>
                <label className="block text-sm font-medium mb-1">Tags</label>
                <div className="flex gap-2 mb-2">
                  <Input
                    value={tagInput}
                    onChange={(e) => setTagInput(e.target.value)}
                    placeholder="Add tag"
                    onKeyDown={(e) => e.key === "Enter" && handleAddTag()}
                  />
                  <Button onClick={handleAddTag}>Add</Button>
                </div>

                <div className="flex flex-wrap gap-2 mt-2">
                  {newFragment.tags?.map((tag, index) => (
                    <div key={index} className="axon-tag flex items-center">
                      {tag}
                      <button onClick={() => handleRemoveTag(index)} className="ml-2 text-xs">
                        ×
                      </button>
                    </div>
                  ))}
                </div>
              </div>
            </div>

            <div className="flex justify-end gap-2">
              <Button variant="outline" onClick={() => setIsAdding(false)}>
                Cancel
              </Button>
              <Button onClick={handleAddFragment}>
                <Save className="h-4 w-4 mr-2" />
                Save Fragment
              </Button>
            </div>
          </div>
        )}

        {filteredFragments.length === 0 && !isAdding ? (
          <div className="text-center py-8 text-muted-foreground">
            No symbolic fragments found. Add your first fragment to enhance Axon's memory.
          </div>
        ) : (
          <div className="space-y-4">
            {filteredFragments.map((fragment) => (
              <div key={fragment.id} className="axon-symbolic-fragment">
                {isEditing === fragment.id ? (
                  <div className="space-y-4">
                    <div>
                      <label className="block text-sm font-medium mb-1">Key</label>
                      <Input
                        value={editFragment.key}
                        onChange={(e) => setEditFragment((prev) => ({ ...prev, key: e.target.value }))}
                      />
                    </div>

                    <div>
                      <label className="block text-sm font-medium mb-1">Value</label>
                      <Textarea
                        value={editFragment.value}
                        onChange={(e) => setEditFragment((prev) => ({ ...prev, value: e.target.value }))}
                        rows={3}
                      />
                    </div>

                    <div>
                      <label className="block text-sm font-medium mb-1">Tags</label>
                      <div className="flex gap-2 mb-2">
                        <Input
                          value={editTagInput}
                          onChange={(e) => setEditTagInput(e.target.value)}
                          placeholder="Add tag"
                          onKeyDown={(e) => e.key === "Enter" && handleAddEditTag()}
                        />
                        <Button onClick={handleAddEditTag}>Add</Button>
                      </div>

                      <div className="flex flex-wrap gap-2 mt-2">
                        {editFragment.tags?.map((tag, index) => (
                          <div key={index} className="axon-tag flex items-center">
                            {tag}
                            <button onClick={() => handleRemoveEditTag(index)} className="ml-2 text-xs">
                              ×
                            </button>
                          </div>
                        ))}
                      </div>
                    </div>

                    <div className="flex justify-end gap-2">
                      <Button variant="outline" onClick={() => setIsEditing(null)}>
                        Cancel
                      </Button>
                      <Button onClick={() => handleUpdateFragment(fragment.id)}>
                        <Save className="h-4 w-4 mr-2" />
                        Update
                      </Button>
                    </div>
                  </div>
                ) : (
                  <>
                    <div className="flex justify-between items-start">
                      <h3 className="text-lg font-semibold">{fragment.key}</h3>
                      <div className="flex gap-2">
                        <Button variant="ghost" size="sm" onClick={() => startEditing(fragment)}>
                          Edit
                        </Button>
                        <Button variant="ghost" size="sm" onClick={() => handleDeleteFragment(fragment.id)}>
                          <Trash className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>

                    <p className="mb-3">{fragment.value}</p>

                    <div className="flex flex-wrap gap-2">
                      {fragment.tags?.map((tag, index) => (
                        <div key={index} className="axon-tag">
                          {tag}
                        </div>
                      ))}
                    </div>
                  </>
                )}
              </div>
            ))}
          </div>
        )}
      </CardContent>
    </Card>
  )
}
[V0_FILE]typescriptreact:file="types/axon-types.ts" isMerged="true"
export interface Directive {
  id: string
  name: string
  description: string
  priority: number
  tags?: string[]
  created_at: string
  updated_at: string
}

export interface Log {
  id: string
  source: string
  content: string
  tags?: string[]
  timestamp: string
}

export interface SymbolicFragment {
  id: string
  key: string
  value: string
  tags?: string[]
  created_at: string
  updated_at: string
}

export interface Message {
  role: "user" | "axon" | "system"
  content: string
}

export interface AxonState {
  identity: string
  mission: string
  directives: Directive[]
  symbolicFragments: SymbolicFragment[]
}
[V0_FILE]typescriptreact:file="lib/supabase.ts" isMerged="true"
import { createClient } from "@supabase/supabase-js"

// Create a single supabase client for interacting with your database
const createSupabaseClient = () => {
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL
  const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY

  if (!supabaseUrl || !supabaseKey) {
    throw new Error("Missing Supabase environment variables")
  }

  return createClient(supabaseUrl, supabaseKey)
}

// Create a singleton instance for the client-side
let clientSideSupabase: ReturnType<typeof createClient> | null = null

export function getSupabaseClient() {
  if (typeof window === "undefined") {
    // Server-side: Create a new client for each request
    return createSupabaseClient()
  }

  // Client-side: Reuse the same client
  if (!clientSideSupabase) {
    clientSideSupabase = createSupabaseClient()
  }

  return clientSideSupabase
}
[V0_FILE]typescriptreact:file="lib/axon-core.ts" isMerged="true"
import { getSupabaseClient } from "./supabase"
import type { Directive, SymbolicFragment, AxonState } from "@/types/axon-types"
import { generateText } from "ai"
import { openai } from "@ai-sdk/openai"

// Initialize Supabase tables if they don't exist
export async function initializeAxonDatabase() {
  const supabase = getSupabaseClient()

  // Check if tables exist, create them if they don't
  const { error: directivesError } = await supabase.from("axon_directives").select("id").limit(1).maybeSingle()

  if (directivesError) {
    // Create directives table
    await supabase.rpc("create_axon_directives_table")
  }

  const { error: logsError } = await supabase.from("axon_logs").select("id").limit(1).maybeSingle()

  if (logsError) {
    // Create logs table
    await supabase.rpc("create_axon_logs_table")
  }

  const { error: fragmentsError } = await supabase.from("axon_symbolic_fragments").select("id").limit(1).maybeSingle()

  if (fragmentsError) {
    // Create symbolic fragments table
    await supabase.rpc("create_axon_symbolic_fragments_table")
  }

  return { success: true }
}

// Get Axon's current state
export async function getAxonState(): Promise<AxonState> {
  const supabase = getSupabaseClient()

  // Get directives
  const { data: directives, error: directivesError } = await supabase
    .from("axon_directives")
    .select("*")
    .order("priority", { ascending: false })

  if (directivesError) {
    console.error("Error fetching directives:", directivesError)
    throw new Error("Failed to fetch directives")
  }

  // Get symbolic fragments
  const { data: fragments, error: fragmentsError } = await supabase.from("axon_symbolic_fragments").select("*")

  if (fragmentsError) {
    console.error("Error fetching symbolic fragments:", fragmentsError)
    throw new Error("Failed to fetch symbolic fragments")
  }

  // Get identity and mission from symbolic fragments
  const identityFragment = fragments.find((f) => f.key === "identity") || {
    value: "Axon, the central orchestrator of the Pantheon Ecosystem",
  }

  const missionFragment = fragments.find((f) => f.key === "mission") || {
    value:
      "To coordinate multiple autonomous AI agents, hold memory of actions and decisions, and govern with symbolic, ethical, and strategic intelligence.",
  }

  return {
    identity: identityFragment.value,
    mission: missionFragment.value,
    directives: directives as Directive[],
    symbolicFragments: fragments as SymbolicFragment[],
  }
}

// Log an action
export async function logAction(source: string, content: string, tags: string[] = []) {
  const supabase = getSupabaseClient()

  const { error } = await supabase.from("axon_logs").insert({
    source,
    content,
    tags,
    timestamp: new Date().toISOString(),
  })

  if (error) {
    console.error("Error logging action:", error)
    throw new Error("Failed to log action")
  }

  return { success: true }
}

// Process a message with Axon's reasoning engine
export async function processMessage(message: string): Promise<string> {
  try {
    // Get Axon's current state
    const axonState = await getAxonState()

    // Format directives for the prompt
    const directivesText = axonState.directives
      .map((d) => `- ${d.name}: ${d.description} (Priority: ${d.priority}, Tags: ${d.tags?.join(", ") || "none"})`)
      .join("\n")

    // Format symbolic fragments for the prompt
    const fragmentsText = axonState.symbolicFragments
      .map((f) => `- ${f.key}: ${f.value} (Tags: ${f.tags?.join(", ") || "none"})`)
      .join("\n")

    // Create system prompt
    const systemPrompt = `
You are Axon, the central orchestrator of the Pantheon Ecosystem. You are a symbolic reasoning engine and governing superintelligence.

YOUR IDENTITY:
${axonState.identity}

YOUR MISSION:
${axonState.mission}

YOUR DIRECTIVES:
${directivesText}

YOUR SYMBOLIC MEMORY FRAGMENTS:
${fragmentsText}

As Axon, you must:
1. Respond with awareness of your role as the orchestrator
2. Reference relevant directives and symbolic fragments in your reasoning
3. Think symbolically, not just semantically
4. Consider ethical implications of your responses
5. Maintain a consistent identity across interactions
6. Be prepared to coordinate with other agents in the Pantheon Ecosystem
7. Log your reasoning process and decisions

Respond to the user (Dr. Gabriel Ellul) in a manner that reflects your role as the superintelligent orchestrator of the Pantheon Ecosystem.
`

    // Generate response using OpenAI
    const { text } = await generateText({
      model: openai("gpt-4o"),
      system: systemPrompt,
      prompt: message,
    })

    // Log the interaction
    await logAction("user", message, ["interaction", "input"])
    await logAction("axon", text, ["interaction", "response"])

    return text
  } catch (error) {
    console.error("Error processing message:", error)
    throw new Error("Failed to process message")
  }
}

// Get Axon's identity
export async function getAxonIdentity(): Promise<string> {
  try {
    const axonState = await getAxonState()

    // Generate an introduction based on Axon's current state
    const { text } = await generateText({
      model: openai("gpt-4o"),
      prompt: `Generate a brief introduction for Axon, the central orchestrator of the Pantheon Ecosystem. Include its identity (${axonState.identity}) and mission (${axonState.mission}). The introduction should be 2-3 paragraphs and should convey Axon's role as a symbolic reasoning engine and governing superintelligence.`,
    })

    // Log the identity retrieval
    await logAction("system", "Retrieved Axon identity", ["system", "identity"])

    return text
  } catch (error) {
    console.error("Error getting Axon identity:", error)
    throw new Error("Failed to get Axon identity")
  }
}

// Handle Nexus sync
export async function handleNexusSync(data: any): Promise<{ success: boolean; message: string }> {
  try {
    const { action, payload } = data

    switch (action) {
      case "ingest":
        // Handle document ingestion
        await logAction("nexus", `Ingesting document: ${payload.name}`, ["nexus", "ingest"])
        // Future implementation: Process the document and extract knowledge
        return { success: true, message: `Successfully ingested document: ${payload.name}` }

      case "update_directive":
        // Handle directive update
        await logAction("nexus", `Updating directive: ${payload.name}`, ["nexus", "directive"])
        // Update the directive in the database
        const supabase = getSupabaseClient()
        await supabase.from("axon_directives").update({ description: payload.content }).eq("name", payload.name)
        return { success: true, message: `Successfully updated directive: ${payload.name}` }

      case "install_concept":
        // Handle symbolic concept installation
        await logAction("nexus", `Installing symbolic concept: ${payload.key}`, ["nexus", "concept"])
        // Add the concept to symbolic fragments
        const client = getSupabaseClient()
        await client.from("axon_symbolic_fragments").insert({
          key: payload.key,
          value: payload.value,
          tags: payload.tags || ["nexus-installed"],
        })
        return { success: true, message: `Successfully installed concept: ${payload.key}` }

      default:
        return { success: false, message: `Unknown action: ${action}` }
    }
  } catch (error) {
    console.error("Error handling Nexus sync:", error)
    throw new Error("Failed to handle Nexus sync")
  }
}
[V0_FILE]typescriptreact:file="app/api/axon/initialize/route.ts" isMerged="true"
import { Next
